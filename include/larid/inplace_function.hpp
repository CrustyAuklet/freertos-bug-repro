/*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
/*
* Copyright (c) 2023, Wildlife Computers
* MODIFICATIONS:
*  - namespace to larid
*  - constexpr constructors
*  - change default size to sizeof(void*)
*  - replace the exception thrown when using an empty function with a larid_Assert
*  - formatting, rearrange special member functions to group by type
*/
#pragma once

#include <type_traits>
#include <utility>
#include <functional>
#include <FreeRTOS.h>


namespace larid {

   namespace inplace_function_detail {

       template<size_t Cap>
       union aligned_storage_helper {
           struct double1 {
               double a;
           };
           struct double4 {
               double a[4];
           };
           template<class T>
           using maybe = std::conditional_t<(Cap >= sizeof(T)), T, char>;
           char real_data[Cap];
           maybe<int> a;
           maybe<long> b;
           maybe<long long> c;
           maybe<void*> d;
           maybe<void (*)()> e;
           maybe<double1> f;
           maybe<double4> g;
           maybe<long double> h;
       };

       static constexpr size_t InplaceFunctionDefaultCapacity = sizeof(void*);

       template<class T>
       struct wrapper {
           using type = T;
       };

       template<class>
       struct is_inplace_function : std::false_type {};

       /**
        * C++11 MSVC compatible implementation of std::is_invocable_r
        * We have to use this version to avoid hitting the issue in LLVM with std::is_invokable_r
        *     - https://bugs.llvm.org/show_bug.cgi?id=32072
        */
       template<class R>
       void accept(R);

       template<class, class R, class F, class... Args>
       struct is_invocable_r_impl : std::false_type {};

       template<class F, class... Args>
       struct is_invocable_r_impl<decltype(std::declval<F>()(std::declval<Args>()...), void()), void, F, Args...>
           : std::true_type {};

       template<class F, class... Args>
       struct is_invocable_r_impl<decltype(std::declval<F>()(std::declval<Args>()...), void()), const void, F, Args...>
           : std::true_type {};

       template<class R, class F, class... Args>
       struct is_invocable_r_impl<decltype(accept<R>(std::declval<F>()(std::declval<Args>()...))), R, F, Args...>
           : std::true_type {};

       template<class R, class F, class... Args>
       using is_invocable_r = is_invocable_r_impl<void, R, F, Args...>;


       template<size_t DstCap, size_t DstAlign, size_t SrcCap, size_t SrcAlign>
       struct is_valid_inplace_dst : std::true_type {
           static_assert(DstCap >= SrcCap, "Can't squeeze larger inplace_function into a smaller one");
           static_assert(DstAlign % SrcAlign == 0, "Incompatible inplace_function alignments");
       };

       template<class R, class... Args>
       struct vtable {
           using storage_ptr_t = void*;

           using invoke_ptr_t = R (*)(storage_ptr_t, Args&&...);
           using process_ptr_t = void (*)(storage_ptr_t, storage_ptr_t);
           using destructor_ptr_t = void (*)(storage_ptr_t);

           const invoke_ptr_t invoke_ptr;
           const process_ptr_t copy_ptr;
           const process_ptr_t relocate_ptr;
           const destructor_ptr_t destructor_ptr;

           // clang-format off
           #pragma warning(disable:4716)
           constexpr explicit vtable() noexcept
               : invoke_ptr([](storage_ptr_t, Args&&...) -> R {
                     configASSERT(false);
                 }),
                 copy_ptr([](storage_ptr_t, storage_ptr_t){}),
                 relocate_ptr([](storage_ptr_t, storage_ptr_t){}),
                 destructor_ptr([](storage_ptr_t){})
           {}
           #pragma warning(default:4716)

           template<class C>
           constexpr explicit vtable(wrapper<C>) noexcept
               : invoke_ptr([](storage_ptr_t storage_ptr, Args&&... args) -> R {
                     return (*static_cast<C*>(storage_ptr))(static_cast<Args&&>(args)...);
                 }),
                 copy_ptr([](storage_ptr_t dst_ptr, storage_ptr_t src_ptr) -> void {
                     ::new (dst_ptr) C((*static_cast<C*>(src_ptr)));
                 }),
                 relocate_ptr([](storage_ptr_t dst_ptr, storage_ptr_t src_ptr) -> void {
                     ::new (dst_ptr) C(std::move(*static_cast<C*>(src_ptr)));
                     static_cast<C*>(src_ptr)->~C();
                 }),
                 destructor_ptr([](storage_ptr_t src_ptr){ static_cast<C*>(src_ptr)->~C(); })
           {}
           // clang-format on

           ~vtable() = default;
           vtable(const vtable&) = delete;
           vtable(vtable&&) = delete;
           vtable& operator=(const vtable&) = delete;
           vtable& operator=(vtable&&) = delete;
       };

       template<class R, class... Args>
       inline constexpr vtable<R, Args...> empty_vtable{};

       template<class R, class... Args>
       struct unique_vtable {
           using storage_ptr_t = void*;

           using invoke_ptr_t = R (*)(storage_ptr_t, Args&&...);
           using process_ptr_t = void (*)(storage_ptr_t, storage_ptr_t);
           using destructor_ptr_t = void (*)(storage_ptr_t);

           const invoke_ptr_t invoke_ptr;
           const process_ptr_t relocate_ptr;
           const destructor_ptr_t destructor_ptr;

           // clang-format off
           #pragma warning(disable:4716)
           constexpr explicit unique_vtable() noexcept
               : invoke_ptr{[](storage_ptr_t, Args&&...) -> R {
                     configASSERT(false);
                 }},
                 relocate_ptr{[](storage_ptr_t, storage_ptr_t){}},
                 destructor_ptr{[](storage_ptr_t){}}
           {}
           #pragma warning(default:4716)

           template<class C>
           constexpr explicit unique_vtable(inplace_function_detail::wrapper<C>) noexcept
               : invoke_ptr{[](storage_ptr_t storage_ptr, Args&&... args) -> R {
                     return (*static_cast<C*>(storage_ptr))(static_cast<Args&&>(args)...);
                 }},
                 relocate_ptr{[](storage_ptr_t dst_ptr, storage_ptr_t src_ptr) -> void {
                     ::new (dst_ptr) C(std::move(*static_cast<C*>(src_ptr)));
                     static_cast<C*>(src_ptr)->~C();
                 }},
                 destructor_ptr{[](storage_ptr_t src_ptr) { static_cast<C*>(src_ptr)->~C(); }}
           {}
           // clang-format on

           ~unique_vtable() = default;
           unique_vtable(const unique_vtable&) = delete;
           unique_vtable(unique_vtable&&) = delete;
           unique_vtable& operator=(const unique_vtable&) = delete;
           unique_vtable& operator=(unique_vtable&&) = delete;
       };

       template<class R, class... Args>
       constexpr unique_vtable<R, Args...> empty_unique_vtable{};

   }  // namespace inplace_function_detail

   template<class Signature,
            size_t Capacity = inplace_function_detail::InplaceFunctionDefaultCapacity,
            size_t Alignment = alignof(inplace_function_detail::aligned_storage_helper<Capacity>)>
   class inplace_function;  // unspecified

   template<class Signature,
            size_t Capacity = inplace_function_detail::InplaceFunctionDefaultCapacity,
            size_t Alignment = alignof(inplace_function_detail::aligned_storage_helper<Capacity>)>
   class unique_inplace_function;  // unspecified

   namespace inplace_function_detail {

       template<class Sig, size_t Cap, size_t Align>
       struct is_inplace_function<inplace_function<Sig, Cap, Align>> : std::true_type {};

       template<class Sig, size_t Cap, size_t Align>
       struct is_inplace_function<unique_inplace_function<Sig, Cap, Align>> : std::true_type {};

   }  // namespace inplace_function_detail

   template<class R, class... Args, size_t Capacity, size_t Alignment>
   class inplace_function<R(Args...), Capacity, Alignment> {
       using vtable_t = inplace_function_detail::vtable<R, Args...>;
       using vtable_ptr_t = const vtable_t*;

       template<class, size_t, size_t>
       friend class inplace_function;

   public:
       using capacity = std::integral_constant<size_t, Capacity>;
       using alignment = std::integral_constant<size_t, Alignment>;

       constexpr inplace_function() noexcept
           : vtable_ptr_(std::addressof(inplace_function_detail::empty_vtable<R, Args...>)),
             storage_()
       {}

       constexpr ~inplace_function() {
           vtable_ptr_->destructor_ptr(std::addressof(storage_));
       }

       constexpr inplace_function(std::nullptr_t) noexcept
           : vtable_ptr_(std::addressof(inplace_function_detail::empty_vtable<R, Args...>)) {}

       template<class T,
                class C = std::decay_t<T>,
                class = std::enable_if_t<!inplace_function_detail::is_inplace_function<C>::value
                                         && std::is_invocable_r_v<R, C&, Args...>>>
       inplace_function(T&& closure) {
           // clang-format off
           static_assert(std::is_copy_constructible_v<C>, "inplace_function cannot be constructed from non-copyable type");
           static_assert(sizeof(C) <= Capacity, "inplace_function cannot be constructed from object with this (large) size");
           static_assert(Alignment % alignof(C) == 0, "inplace_function cannot be constructed from object with this (large) alignment");
           // clang-format on

           static vtable_t vt{inplace_function_detail::wrapper<C>{}};
           vtable_ptr_ = std::addressof(vt);

           ::new (std::addressof(storage_)) C(std::forward<T>(closure));
       }

       // clang-format off
       template<size_t Cap, size_t Align>
       constexpr inplace_function(inplace_function<R(Args...), Cap, Align>&& other) noexcept
           : inplace_function(other.vtable_ptr_, other.vtable_ptr_->relocate_ptr, std::addressof(other.storage_))
       {
           static_assert(inplace_function_detail::is_valid_inplace_dst<Capacity, Alignment, Cap, Align>::value, "conversion not allowed");
           other.vtable_ptr_ = std::addressof(inplace_function_detail::empty_vtable<R, Args...>);
       }

       constexpr inplace_function(inplace_function&& other) noexcept
           : vtable_ptr_(std::exchange(other.vtable_ptr_, std::addressof(inplace_function_detail::empty_vtable<R, Args...>)))
       {
           vtable_ptr_->relocate_ptr(std::addressof(storage_), std::addressof(other.storage_));
       }

       constexpr inplace_function(const inplace_function& other) : vtable_ptr_(other.vtable_ptr_) {
           vtable_ptr_->copy_ptr(std::addressof(storage_), std::addressof(other.storage_));
       }

       template<size_t Cap, size_t Align>
       constexpr inplace_function(const inplace_function<R(Args...), Cap, Align>& other)
           : inplace_function(other.vtable_ptr_, other.vtable_ptr_->copy_ptr, std::addressof(other.storage_))
       {
           static_assert(inplace_function_detail::is_valid_inplace_dst<Capacity, Alignment, Cap, Align>::value, "conversion not allowed");
       }
       // clang-format on

       constexpr inplace_function& operator=(std::nullptr_t) noexcept {
           vtable_ptr_->destructor_ptr(std::addressof(storage_));
           vtable_ptr_ = std::addressof(inplace_function_detail::empty_vtable<R, Args...>);
           return *this;
       }

       constexpr inplace_function& operator=(inplace_function other) noexcept {
           vtable_ptr_->destructor_ptr(std::addressof(storage_));

           vtable_ptr_ = std::exchange(other.vtable_ptr_,
                                       std::addressof(inplace_function_detail::empty_vtable<R, Args...>));
           vtable_ptr_->relocate_ptr(std::addressof(storage_), std::addressof(other.storage_));
           return *this;
       }

       constexpr R operator()(Args... args) const {
           return vtable_ptr_->invoke_ptr(std::addressof(storage_), std::forward<Args>(args)...);
       }

       constexpr bool operator==(std::nullptr_t) const noexcept {
           return !operator bool();
       }

       constexpr bool operator!=(std::nullptr_t) const noexcept {
           return operator bool();
       }

       constexpr explicit operator bool() const noexcept {
           return vtable_ptr_ != std::addressof(inplace_function_detail::empty_vtable<R, Args...>);
       }

       void swap(inplace_function& other) noexcept {
           if (this == std::addressof(other)) {
               return;
           }

           alignas(Alignment) uint8_t tmp[Capacity];
           vtable_ptr_->relocate_ptr(std::addressof(tmp), std::addressof(storage_));
           other.vtable_ptr_->relocate_ptr(std::addressof(storage_), std::addressof(other.storage_));
           vtable_ptr_->relocate_ptr(std::addressof(other.storage_), std::addressof(tmp));
           std::swap(vtable_ptr_, other.vtable_ptr_);
       }

       friend void swap(inplace_function& lhs, inplace_function& rhs) noexcept {
           lhs.swap(rhs);
       }

   private:
       vtable_ptr_t vtable_ptr_;
       alignas(Alignment) mutable uint8_t storage_[Capacity];

       inplace_function(vtable_ptr_t vtable_ptr,
                        typename vtable_t::process_ptr_t process_ptr,
                        typename vtable_t::storage_ptr_t storage_ptr)
           : vtable_ptr_(vtable_ptr) {
           process_ptr(std::addressof(storage_), storage_ptr);
       }
   };

   template<class R, class... Args, size_t Capacity, size_t Alignment>
   class unique_inplace_function<R(Args...), Capacity, Alignment> {
       using vtable_t = inplace_function_detail::unique_vtable<R, Args...>;
       using vtable_ptr_t = const vtable_t*;

       template<class, size_t, size_t>
       friend class unique_inplace_function;

   public:
       using capacity = std::integral_constant<size_t, Capacity>;
       using alignment = std::integral_constant<size_t, Alignment>;

       constexpr unique_inplace_function() noexcept
           : vtable_ptr_(std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>)),
             storage_()
       {}

       constexpr ~unique_inplace_function() {
           vtable_ptr_->destructor_ptr(std::addressof(storage_));
       }

       constexpr unique_inplace_function(std::nullptr_t) noexcept
           : vtable_ptr_(std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>)) {}

       template<class T,
                class C = std::decay_t<T>,
                class = std::enable_if_t<!inplace_function_detail::is_inplace_function<C>::value
                                         && std::is_invocable_r_v<R, C&, Args...>>>
       unique_inplace_function(T&& closure) {
           // clang-format off
           static_assert(sizeof(C) <= Capacity, "unique_inplace_function cannot be constructed from object with this (large) size");
           static_assert(Alignment % alignof(C) == 0, "unique_inplace_function cannot be constructed from object with this (large) alignment");
           // clang-format on

           static const vtable_t vt{inplace_function_detail::wrapper<C>{}};
           vtable_ptr_ = std::addressof(vt);

           ::new (std::addressof(storage_)) C(std::forward<T>(closure));
       }

       // clang-format off
       template<size_t Cap, size_t Align>
       constexpr unique_inplace_function(unique_inplace_function<R(Args...), Cap, Align>&& other) noexcept
           : unique_inplace_function(other.vtable_ptr_, other.vtable_ptr_->relocate_ptr, std::addressof(other.storage_))
       {
           static_assert(inplace_function_detail::is_valid_inplace_dst<Capacity, Alignment, Cap, Align>::value, "conversion not allowed");
           other.vtable_ptr_ = std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>);
       }

       constexpr unique_inplace_function(unique_inplace_function&& other) noexcept
           : vtable_ptr_(std::exchange(other.vtable_ptr_, std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>)))
       {
           vtable_ptr_->relocate_ptr(std::addressof(storage_), std::addressof(other.storage_));
       }
       // clang-format on

       constexpr unique_inplace_function& operator=(std::nullptr_t) noexcept {
           vtable_ptr_->destructor_ptr(std::addressof(storage_));
           vtable_ptr_ = std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>);
           return *this;
       }

       constexpr unique_inplace_function& operator=(unique_inplace_function other) noexcept {
           vtable_ptr_->destructor_ptr(std::addressof(storage_));

           vtable_ptr_ = std::exchange(other.vtable_ptr_,
                                       std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>));
           vtable_ptr_->relocate_ptr(std::addressof(storage_), std::addressof(other.storage_));
           return *this;
       }

       constexpr R operator()(Args... args) const {
           return vtable_ptr_->invoke_ptr(std::addressof(storage_), std::forward<Args>(args)...);
       }

       constexpr bool operator==(std::nullptr_t) const noexcept {
           return !operator bool();
       }

       constexpr bool operator!=(std::nullptr_t) const noexcept {
           return operator bool();
       }

       constexpr explicit operator bool() const noexcept {
           return vtable_ptr_ != std::addressof(inplace_function_detail::empty_unique_vtable<R, Args...>);
       }

       void swap(unique_inplace_function& other) noexcept {
           if (this == std::addressof(other)) {
               return;
           }

           alignas(Alignment) uint8_t tmp[Capacity];
           vtable_ptr_->relocate_ptr(std::addressof(tmp), std::addressof(storage_));
           other.vtable_ptr_->relocate_ptr(std::addressof(storage_), std::addressof(other.storage_));
           vtable_ptr_->relocate_ptr(std::addressof(other.storage_), std::addressof(tmp));
           std::swap(vtable_ptr_, other.vtable_ptr_);
       }

       friend void swap(unique_inplace_function& lhs, unique_inplace_function& rhs) noexcept {
           lhs.swap(rhs);
       }

   private:
       vtable_ptr_t vtable_ptr_;
       alignas(Alignment) mutable uint8_t storage_[Capacity];

       unique_inplace_function(vtable_ptr_t vtable_ptr,
                               typename vtable_t::process_ptr_t process_ptr,
                               typename vtable_t::storage_ptr_t storage_ptr)
           : vtable_ptr_(vtable_ptr) {
           process_ptr(std::addressof(storage_), storage_ptr);
       }
   };

}  // namespace larid
